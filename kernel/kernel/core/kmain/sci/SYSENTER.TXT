
 SYSENTER instruction on Intel processors.
 See:
 https://wiki.osdev.org/SYSENTER


 INTEL: SYSENTER/SYSEXIT
Description
"Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT.
The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to
operating system or executive procedures running at privilege level 0." -- Intel IA-32 (64) programming manual, volume 2B.

Registers
MSRs
These must be accessed through rdmsr and wrmsr

IA32_SYSENTER_CS (0x174)
Contains ring 0 code segment (CS).
Ring 0 data = CS + 8.
If REX.W prefix is used with SYSEXIT, ring 3 code = CS + 32 and ring 3 data = CS + 40.
Otherwise, ring 3 code = CS + 16 and ring 3 data = CS + 24.
These values cannot be changed, therefore your GDT must be structured as such.

IA32_SYSENTER_ESP (0x175) - The kernel's ESP for SYSENTER.
IA32_SYSENTER_EIP (0x176) - The kernel's EIP for SYSENTER. This is the address of your SYSENTER entry point.
CPU registers
These must be set by the application, or the C library wrapper

ECX: Ring 3 Stack pointer for SYSEXIT
EDX: Ring 3 Return address
Operation
When SYSENTER is called, CS is set to the value in IA32_SYSENTER_CS. SS is set 
to IA32_SYSENTER_CS + 8. EIP is loaded from IA32_SYSENTER_EIP and ESP is loaded from IA32_SYSENTER_ESP. 
The CPU is now in ring 0, with EFLAGS.IF=0, EFLAGS.VM=0, EFLAGS.RF=0.

When SYSEXIT is called, CS is set to IA32_SYSENTER_CS+16. 
EIP is set to EDX. SS is set to IA32_SYSENTER_CS+24, and ESP is set to ECX.

Notes: ECX and EDX are not automatically saved as the return address and Stack Pointer. 
These need to be saved in Ring 3.

64 bit mode
Operation in 64 bit mode is exactly the same. IA32_SYSENTER_ESP and IA32_SYSENTER_EIP are 
extended to 64 bits (get rid of reserved bits).

=================================================
Generated by Copilot. Not tested.

#include <stdint.h>
#include <stdio.h>

#define MSR_IA32_SYSENTER_CS    0x174
#define MSR_IA32_SYSENTER_ESP   0x175
#define MSR_IA32_SYSENTER_EIP   0x176

static inline void write_msr(uint32_t msr, uint64_t value) {
    uint32_t low = value & 0xFFFFFFFF;
    uint32_t high = value >> 32;
    asm volatile (
        "wrmsr"
        :
        : "c"(msr), "a"(low), "d"(high)
    );
}

void sysenter_init(uint64_t kernel_cs, uint64_t kernel_rsp, uint64_t kernel_rip) {
    write_msr(MSR_IA32_SYSENTER_CS, kernel_cs);
    write_msr(MSR_IA32_SYSENTER_ESP, kernel_rsp);
    write_msr(MSR_IA32_SYSENTER_EIP, kernel_rip);
}

int xxx() {
    // Example values; should be set according to your OS context
    uint64_t kernel_cs = 0x10;  // Code segment selector for long mode
    uint64_t kernel_rsp = 0xFFFF800000000000;  // Kernel stack pointer
    uint64_t kernel_rip = 0xFFFFFFFF80000000;  // System call entry point

    sysenter_init(kernel_cs, kernel_rsp, kernel_rip);
    printf("SYSENTER initialized for x86_64.\n");

    return 0;
}

